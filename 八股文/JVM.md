1. Serial GC
   (1) 串行GC
   (2) 单线程执行GC，会触发STW
   (3) 适用于单核CPU
2. Parallel GC
   (1) 并行GC
   (2) 多线程执行GC，会触发STW
   (3) 适用于多核CPU
3. CMS GC
   (1) 并发标记清除GC
   (2) 多线程执行GC，不会触发STW
   (3) 适用于多核CPU
4. G1 GC
   (1) 分代式GC
   (2) 多线程执行GC，不会触发STW
   (3) 适用于多核CPU
5. ZGC
   (1) 分代式GC
   (2) 多线程执行GC，不会触发STW
   (3) 适用于多核CPU
6. Shenandoah GC
   (1) 分代式GC
   (2) 多线程执行GC，不会触发STW
   (3) 适用于多核CPU
7. JVM类加载机制
    (1) 双亲委派模型
    (2) 类加载器
    (3) 类加载过程
8. GC roots
    (1) 虚拟机栈中引用的对象
    (2) 方法区中类静态属性引用的对象
    (3) 方法区中常量引用的对象
    (4) 本地方法栈中JNI引用的对象
9. 垃圾回收算法
    (1) 标记清除算法 `内存碎片化`
    (2) 标记整理算法  `效率低`
    (3) 复制算法 `浪费空间`
10. JVM参数
（1）-XX: MaxTenuringThreshold
11. 双亲委派模型是什么
（1）双亲委派模型是一种类加载机制
（2）双亲委派模型是一种树形结构
（3）双亲委派模型是一种类加载器的层次结构
（4）双亲委派模型是一种类加载器的工作方式
12. OSGI（动态模型系统）是什么
（1）OSGI是一种类加载机制
13. 什么时候会触发Full GC
（1）老年代空间不足
（2）System.gc()调用
（3）某些JVM内部机制，如分代回收策略，也可能触发Full GC。例如，在进行多次Minor GC（针对年轻代的垃圾回收）后，JVM可能决定进行一次Full GC以清理整个堆空间。
（4）当创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC；
（5）通过Minor GC后进入老年代的平均大小大于老年代的可用内存时，也会触发Full GC
14. 类加载器
（1）BootstrapClassLoader
（2）ExtClassLoader
（3）AppClassLoader
15. 描述一下JVM加载class文件的原理机制
（1）加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口
（2）验证 ：确保加载的类信息符合JVM规范，没有安全方面的问题
（3）准备 ：正式为类变量（static）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
（4）解析：虚拟机将常量池内的符号引用替换为直接引用的过程
（5）初始化 ：真正开始执行类中定义的java程序代码（字节码）
16. Java对象的创建过程
（1）类加载检查：检查是否已经加载过
（2）分配内存：在堆内存中分配对象所需要的内存空间
（3）初始化零值：将对象的实例变量都初始化为零值
（4）设置对象头：设置对象的类型指针，对象的哈希码，对象的GC分代年龄
（5）执行init方法：执行对象的构造方法，初始化对象



